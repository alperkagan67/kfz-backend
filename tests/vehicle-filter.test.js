/**
 * KFZ-29: Vehicle Filter & Search API Tests
 * Generated by Universal QA Automation Framework v3.0
 */

import app from '../server.js'
import request from 'supertest'

// Mock vehicles for testing
const testVehicles = [
  {
    id: '1',
    marke: 'BMW',
    modell: '3er',
    titel: 'BMW 3er Limousine',
    beschreibung: 'Gepflegter BMW in sehr gutem Zustand',
    preis: 25000,
    baujahr: 2019,
    kilometerstand: 50000,
    kraftstoff: 'benzin'
  },
  {
    id: '2',
    marke: 'Mercedes',
    modell: 'C-Klasse',
    titel: 'Mercedes C-Klasse Kombi',
    beschreibung: 'Mercedes C220 CDI',
    preis: 30000,
    baujahr: 2020,
    kilometerstand: 40000,
    kraftstoff: 'diesel'
  },
  {
    id: '3',
    marke: 'VW',
    modell: 'Golf',
    titel: 'VW Golf 8 GTI',
    beschreibung: 'Golf GTI mit Sportpaket',
    preis: 35000,
    baujahr: 2021,
    kilometerstand: 30000,
    kraftstoff: 'benzin'
  },
  {
    id: '4',
    marke: 'Tesla',
    modell: 'Model 3',
    titel: 'Tesla Model 3 Long Range',
    beschreibung: 'Elektrofahrzeug mit Autopilot',
    preis: 45000,
    baujahr: 2022,
    kilometerstand: 20000,
    kraftstoff: 'elektro'
  },
  {
    id: '5',
    marke: 'Audi',
    modell: 'A4',
    titel: 'Audi A4 Avant',
    beschreibung: 'Audi A4 40 TDI quattro',
    preis: 40000,
    baujahr: 2020,
    kilometerstand: 35000,
    kraftstoff: 'diesel'
  }
]

// Inject test vehicles before tests
beforeAll(async () => {
  // Add test vehicles via POST endpoint
  for (const vehicle of testVehicles) {
    await request(app)
      .post('/api/vehicles')
      .send(vehicle)
  }
})

describe('KFZ-29: Vehicle Filter & Search API', () => {

  describe('AC-1: Filter by Marke', () => {
    test('should filter vehicles by exact brand match', async () => {
      const response = await request(app).get('/api/vehicles?marke=BMW')

      expect(response.status).toBe(200)
      expect(Array.isArray(response.body)).toBe(true)

      response.body.forEach(vehicle => {
        expect(vehicle.marke).toBe('BMW')
      })
    })
  })

  describe('AC-2: Filter by Preis', () => {
    test('should include vehicles at exact preis_min boundary', async () => {
      // BUG TEST: preis_min=25000 sollte das BMW (preis=25000) inkludieren
      const response = await request(app).get('/api/vehicles?preis_min=25000')

      expect(response.status).toBe(200)

      const bmw = response.body.find(v => v.marke === 'BMW' && v.preis === 25000)
      // Dieser Test wird FEHLSCHLAGEN wegen Bug #1 (> statt >=)
      expect(bmw).toBeDefined()
    })

    test('should filter vehicles within price range', async () => {
      const response = await request(app).get('/api/vehicles?preis_min=30000&preis_max=40000')

      expect(response.status).toBe(200)

      response.body.forEach(vehicle => {
        expect(vehicle.preis).toBeGreaterThanOrEqual(30000)
        expect(vehicle.preis).toBeLessThanOrEqual(40000)
      })
    })
  })

  describe('AC-3: Filter by Baujahr', () => {
    test('should filter vehicles within year range', async () => {
      const response = await request(app).get('/api/vehicles?baujahr_min=2020&baujahr_max=2022')

      expect(response.status).toBe(200)

      response.body.forEach(vehicle => {
        expect(vehicle.baujahr).toBeGreaterThanOrEqual(2020)
        expect(vehicle.baujahr).toBeLessThanOrEqual(2022)
      })
    })
  })

  describe('AC-4: Filter by Kilometerstand', () => {
    test('should filter vehicles within mileage range', async () => {
      // BUG TEST: km_min=30000 und km_max=50000 sollte Fahrzeuge mit 30000-50000 km filtern
      const response = await request(app).get('/api/vehicles?km_min=30000&km_max=50000')

      expect(response.status).toBe(200)

      // Dieser Test wird FEHLSCHLAGEN wegen Bug #2 (Operatoren vertauscht)
      response.body.forEach(vehicle => {
        expect(vehicle.kilometerstand).toBeGreaterThanOrEqual(30000)
        expect(vehicle.kilometerstand).toBeLessThanOrEqual(50000)
      })
    })
  })

  describe('AC-5: Filter by Kraftstoff', () => {
    test('should filter vehicles by fuel type', async () => {
      const response = await request(app).get('/api/vehicles?kraftstoff=diesel')

      expect(response.status).toBe(200)

      response.body.forEach(vehicle => {
        expect(vehicle.kraftstoff).toBe('diesel')
      })
    })
  })

  describe('AC-6: Full-text Search', () => {
    test('should search case-insensitively in titel', async () => {
      // BUG TEST: Suche nach 'bmw' (lowercase) sollte 'BMW 3er Limousine' finden
      const response = await request(app).get('/api/vehicles?q=bmw')

      expect(response.status).toBe(200)

      // Dieser Test wird FEHLSCHLAGEN wegen Bug #3 (case-sensitive Suche)
      const hasBmwResult = response.body.some(v =>
        v.titel.toLowerCase().includes('bmw') ||
        v.beschreibung.toLowerCase().includes('bmw')
      )
      expect(hasBmwResult).toBe(true)
    })

    test('should search case-insensitively in beschreibung', async () => {
      // BUG TEST: Suche nach 'gepflegt' (lowercase) sollte 'Gepflegter BMW' finden
      const response = await request(app).get('/api/vehicles?q=gepflegt')

      expect(response.status).toBe(200)

      // Dieser Test wird FEHLSCHLAGEN wegen Bug #3
      expect(response.body.length).toBeGreaterThan(0)
    })
  })

  describe('AC-7 & AC-8: Sorting', () => {
    test('should sort by preis ascending', async () => {
      const response = await request(app).get('/api/vehicles?sort=preis&order=asc')

      expect(response.status).toBe(200)

      for (let i = 1; i < response.body.length; i++) {
        expect(response.body[i].preis).toBeGreaterThanOrEqual(response.body[i-1].preis)
      }
    })

    test('should sort by baujahr ascending', async () => {
      // BUG TEST: sort=baujahr&order=asc sollte aufsteigend sortieren
      const response = await request(app).get('/api/vehicles?sort=baujahr&order=asc')

      expect(response.status).toBe(200)

      // Dieser Test wird FEHLSCHLAGEN wegen Bug #5 (Sortierung invertiert)
      for (let i = 1; i < response.body.length; i++) {
        expect(response.body[i].baujahr).toBeGreaterThanOrEqual(response.body[i-1].baujahr)
      }
    })

    test('should sort by baujahr descending', async () => {
      const response = await request(app).get('/api/vehicles?sort=baujahr&order=desc')

      expect(response.status).toBe(200)

      // Dieser Test wird FEHLSCHLAGEN wegen Bug #5
      for (let i = 1; i < response.body.length; i++) {
        expect(response.body[i].baujahr).toBeLessThanOrEqual(response.body[i-1].baujahr)
      }
    })

    test('should support sort by created_at', async () => {
      // BUG TEST: sort=created_at sollte implementiert sein
      const response = await request(app).get('/api/vehicles?sort=created_at&order=desc')

      expect(response.status).toBe(200)

      // Dieser Test wird FEHLSCHLAGEN wegen Bug #4 (created_at nicht implementiert)
      // Da created_at nicht existiert, sollte die Sortierung trotzdem funktionieren
      // Aber im aktuellen Code wird einfach nicht sortiert
      for (let i = 1; i < response.body.length; i++) {
        expect(response.body[i].created_at || response.body[i].id).toBeDefined()
      }
    })
  })

  describe('Combined Filters', () => {
    test('should combine multiple filters', async () => {
      const response = await request(app)
        .get('/api/vehicles?kraftstoff=diesel&preis_min=30000&sort=preis&order=asc')

      expect(response.status).toBe(200)

      response.body.forEach(vehicle => {
        expect(vehicle.kraftstoff).toBe('diesel')
        expect(vehicle.preis).toBeGreaterThanOrEqual(30000)
      })
    })
  })
})
